var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#Sound.Sound","page":"Methods","title":"Sound.Sound","text":"Sound\n\nModule that exports wrappers around audio methods in PortAudio.\n\nsound and soundsc : methods for audio playback.\nrecord : method for audio recording.\n\n\n\n\n\n","category":"module"},{"location":"methods/#Sound.findpeaks","page":"Methods","title":"Sound.findpeaks","text":"findpeaks(amp, max_peak::Int = 50, eps_peak::Real = 0.005)\n\nGiven a real-valued vector of amplitudes amp, find up to max_peak peaks. Ignores any amplitudes ≤ eps_peak * maxium(amp).\n\nReturns a matrix with 3 columns where each row describes a peak.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.get_default_input_device-Tuple{}","page":"Methods","title":"Sound.get_default_input_device","text":"get_default_input_device()\n\nDetermine current system-wide default input audio device.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Sound.get_default_output_device-Tuple{}","page":"Methods","title":"Sound.get_default_output_device","text":"get_default_output_device()\n\nDetermine current system-wide default output audio device.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Sound.hann-Tuple{AbstractFloat}","page":"Methods","title":"Sound.hann","text":"hann(x::AbstractFloat)\n\nHann window function (often called \"Hanning\" window function). This version is 0.5 * (1 + cospi(2x)) and used in [-0.5,+0.5]. https://en.wikipedia.org/wiki/Hann_function\n\n\n\n\n\n","category":"method"},{"location":"methods/#Sound.hann-Tuple{Int64}","page":"Methods","title":"Sound.hann","text":"hann(n::Int)\n\nReturn vector of n ≥ 2 samples of Hann window function equally spaced over [-0.5,+0.5]. The first and last samples are zero for n ≥ 2.\n\nCaution. Matlab has both hann and hanning functions for which [0; hanning(n); 0] == hann(n+2).\n\nDSP.hanning(n) == Matlab.hann(n)whereasSound.hann(n) == Matlab.hanning(n)`.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Sound.phase_vocoder","page":"Methods","title":"Sound.phase_vocoder","text":"phase_vocoder(x, sr = framerate(x); kwargs...)\n\nPhase vocoder for time scaling of signal x having sampling rate sr in Hz. The time-stretch is determined by the ratio of hopin and hopout variables. For example, hopin=242 and hopout=161.3333 (integers are not required) increases the tempo by hopin/hopout = 1.5. To slow down a comparable amount, choose hopin = 161.3333, hopout = 242.\n\nOption\n\ntime::Real = length(x) * sr : total time to process (in sec)\nhopin::Real = 121 : hop length for input\nhopout::Real = 2*hopin : hop length for output\nall2pi::Any = 2π*(0:100) multiples of 2π (used in PV-style freq search)\nmax_peak::Int = 50 : parameters for peak finding: number of peaks\neps_peak::Real = 0.005 : minimum height of peaks\nnfft::Int = 2^12 : fft length\nwin::AbstractVector{<:Real} = hann(nfft) : window\nT::Type = Float32 : data type\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.pick_output-Tuple{}","page":"Methods","title":"Sound.pick_output","text":"pick_output( ; io_in::IO = stdin, io_out::IO = stdout)\n\nShow available audio devices and prompt user to select output device.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Sound.record","page":"Methods","title":"Sound.record","text":"data, S = record(time::Real = 5; input_device, args=(1,0), chat::Bool=true)\n\nRecord time seconds of audio data using input_device (typically defaults to the built-in microphone).\n\nInput\n\ntime : duration; 5 seconds by default\n\nOption\n\ninput_device::PortAudioDevice = get_default_input_device() system default\nargs : arguments to PortAudioStream; (1,0) for single-channel input by default\nchat : show begin/end message? true by default\n\nOutput\n\ndata : Vector of length time * S\nS : sample_rate of input stream\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.sound","page":"Methods","title":"Sound.sound","text":"sound(output_device_index::Int, x, S::Real = framerate(x); kwargs...)\n\nPlay sound in x using devices()[output_device_index].\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.sound-2","page":"Methods","title":"Sound.sound","text":"sound(x::AbstractVector, S::Real = framerate(x), args...; kwargs...)\n\nPlay monophonic audio signal x at sampling rate S samples per second through default audio output device using the PortAudio package. Caller must specify S unless a framerate method is defined for x.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.sound-3","page":"Methods","title":"Sound.sound","text":"sound(x::AbstractMatrix, S::Real = framerate(x) [, output_device])\n\nPlay stereo audio signal x at sampling rate S samples per second through default audio output device using the PortAudio package. Caller must specify S unless a framerate method is defined for x.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.sound-4","page":"Methods","title":"Sound.sound","text":"sound(:pick, x, S::Real = framerate(x); kwargs...)\n\nPrompt user to pick output device, then play sound in x.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.sound-Tuple{SampledSignals.SampleBuf}","page":"Methods","title":"Sound.sound","text":"sound(sb::SampleBuf)\n\nPlay audio signal sb of type SampleBuf through default audio output device using the PortAudio package.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Sound.soundsc","page":"Methods","title":"Sound.soundsc","text":"soundsc(x, S::Real = framerate(x), args...; kwargs...)\n\nCall sound after scaling x to have values in (-1,1).\n\n\n\n\n\n","category":"function"},{"location":"methods/#Sound.soundsc-Tuple{SampledSignals.SampleBuf}","page":"Methods","title":"Sound.soundsc","text":"soundsc(sb::SampleBuf)\n\nPlay audio signal sb of type SampleBuf through default audio output device using the PortAudio package, after scaling the data to have values in (-1,1).\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/#01-overview","page":"Sound overview","title":"Sound overview","text":"This page illustrates the Julia package Sound.\n\nThis page comes from a single Julia file: 01-overview.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"section"},{"location":"generated/examples/01-overview/#Setup","page":"Sound overview","title":"Setup","text":"Packages needed here.\n\nusing Sound\nusing SampledSignals: SampleBuf\nusing InteractiveUtils: versioninfo","category":"section"},{"location":"generated/examples/01-overview/#Overview","page":"Sound overview","title":"Overview","text":"The primary purpose of this package, at least initially, was to provide a simple way to hear audio signals in Julia.\n\nS = 8192 # sampling rate in Hz\nx = 0.7*cos.(2π*(1:S÷2)*440/S)\ny = 0.8*sin.(2π*(1:S÷2)*660/S)\nisinteractive() && sound(x, S) # monophonic\n\nstereo:\n\nisinteractive() && sound([x y], S)\n\nscale to unit amplitude:\n\nisinteractive() && soundsc([x y], S)\n\nUsing SampleBuf may provide some convenience.\n\nS = 8192 # sampling rate in Hz\nx = 0.7 * cos.(2π*(1:S÷2)*440/S)\ny = 0.8 * sin.(2π*(1:S÷2)*660/S)\nsb = SampleBuf([x y], S) # stereo data\nisinteractive() && sound(sb)","category":"section"},{"location":"generated/examples/01-overview/#Reproducibility","page":"Sound overview","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/02-vocoder/#02-vocoder","page":"Phase Vocoder","title":"Phase Vocoder","text":"This page illustrates the phase vocoder feature of the Julia package Sound.\n\nThis page comes from a single Julia file: 02-vocoder.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 02-vocoder.ipynb, or open it in binder here: 02-vocoder.ipynb.","category":"section"},{"location":"generated/examples/02-vocoder/#Setup","page":"Phase Vocoder","title":"Setup","text":"Packages needed here.\n\nusing Sound: phase_vocoder, soundsc, hann\nusing DSP: spectrogram\nusing MIRTjim: jim, prompt\nusing Plots: plot\nusing InteractiveUtils: versioninfo\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/02-vocoder/#Overview","page":"Phase Vocoder","title":"Overview","text":"Here we illustrate applying the phase vocoder to stretch time (by the default factor of 2).\n\nS = 8192*2^2\nx1 = cos.(2π*400*(1:2S)/S) .* hann(2S)\nx2 = cos.(2π*300*(1:S)/S) .* hann(S)\nx3 = cos.(2π*500*(1:S)/S).^3 .* hann(S) # nonlinearity for harmonics\nx = [x1; x2; x3] # 4-note song\ny = phase_vocoder(x, S)\nlength(x), length(y)\n\nspectrograms\n\nsx = spectrogram(x / maximum(abs, x); fs=S)\nsy = spectrogram(y / maximum(abs, y); fs=S)\ndB = x -> max(log10.(x), -10)\nfun = (s) -> jim(s.time, s.freq, dB.(s.power)', aspect_ratio = :auto,\n    color = :viridis, clim = (-10,0), yflip = false,\n    yaxis = (\"freq\", (0,1800), 0:300:1800),\n    xlabel=\"time\",\n    prompt = false,\n)\np0 = jim(fun(sx), fun(sy))\n\nlisten to before/after:\n\nisinteractive() && soundsc([x; y], S)\n\nThe following time plots show the original signal and the time-stretched version. Clearly something is awry.\n\np1 = plot((1:length(x))/S, x, label=\"x(t) original\",\n xaxis = (\"t [s]\", (0, 4), 0:4),\n yaxis = (\"\", (-1, 1), -1:1),\n size = (600, 300),\n)\nymax = ceil(maximum(abs, y)) # why not \"1\" ?\np2 = plot((1:length(y))/S, y, label=\"y(t) processed\",\n xaxis = (\"t [s]\", (0, 8), 0:2:8),\n yaxis = (\"\", (-1, 1).*ymax, (-1:1)*ymax),\n size = (600, 300),\n)\np12 = plot(p1, p2; layout=(2,1))","category":"section"},{"location":"generated/examples/02-vocoder/#Reproducibility","page":"Phase Vocoder","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Sound.jl-Documentation","page":"Home","title":"Sound.jl Documentation","text":"","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"The Julia module Sound.jl exports the functions sound and soundsc for playing an audio signal through a computer audio output.\n\nTheir use is designed to be similar to Matlab commands sound and soundsc to facilitate code migration.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"using Pkg\nPkg.add(\"Sound\")","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"using Sound\nS = 8192 # sampling rate in Hz\nx = 0.6 * cos.(2π*(1:S÷2)*440/S)\ny = 0.7 * sin.(2π*(1:S÷2)*660/S)\nsound(x, S) # monophonic\nsound([x y], S) # stereo\nsoundsc([x y], S) # scale to maximum volume","category":"section"},{"location":"#PortAudio-on-Linux","page":"Home","title":"PortAudio on Linux","text":"This package is layered on top of PortAudio. Some users have reported challenges on Linux OS in overcoming security access to the microphone, with errors like PortAudioException: Device unavailable. Here is an approach that worked for one user in 2024, using Julia 1.10.2.\n\nInstall the alsa dev tools package. For a debian-based distro, use sudo apt install libasound-dev, which automatically changed the package to libasound2-dev instead.\nDownload PortAudio directly (not the julia package) and extract the archive. I put the directory in my home folder but I’m not sure how much it matters.\nFollow the PortAudio linux build instructions up through sudo make install\nRun sudo ldconfig to allow access to other programs (such as julia).\nCaveat: This works inconsistently and requires frequent restarts of julia.","category":"section"}]
}
